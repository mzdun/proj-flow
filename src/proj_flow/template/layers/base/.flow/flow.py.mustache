#!/usr/bin/env python3

# Copyright (c) 2025 Marcin Zdun
# This code is licensed under MIT license (see LICENSE for details)

import os
import re
import shutil
import subprocess
import sys
from contextlib import contextmanager
from dataclasses import dataclass
from functools import total_ordering
from pathlib import Path
from typing import cast

PROJ_FLOW_VERSION = "{{__flow_version__}}"
PROJECT_ROOT = Path(__file__).parent.parent
VER_REGEX = re.compile(r"((?:0|[1-9][0-9]*)\.(?:0|[1-9][0-9]*)\.(?:0|[1-9][0-9]*))")


@dataclass
@total_ordering
class Version:
    major: int
    minor: int
    patch: int

    def __str__(self):
        return f"{self.major}.{self.minor}.{self.patch}"

    def __lt__(self, other):
        if not isinstance(other, Version):
            return False
        if self.major != other.major:
            return self.major < other.major
        if self.minor != other.minor:
            return self.minor < other.minor
        return self.patch < other.patch

    def __eq__(self, other):
        if not isinstance(other, Version):
            return False
        return (
            self.major == other.major
            and self.minor == other.minor
            and self.patch == other.patch
        )

    def compatible_with(self, runtime: "Version | None"):
        return self <= runtime and self.major == cast(Version, runtime).major

    @staticmethod
    def parse(value: str):
        chunks = value.split("-")[0].split("+")[0].split(".")

        int_chunks = list(map(int, chunks))[0:3]
        while len(int_chunks) < 3:
            int_chunks.append(0)
        return Version(*int_chunks)

    @staticmethod
    def proc_parse(process: subprocess.CompletedProcess):
        value = cast(str, process.stdout).strip() if process.returncode == 0 else ""
        m = VER_REGEX.search(value)
        try:
            return Version.parse(m.group(0)) if m is not None else None
        except ValueError:
            return None


proj_flow = Version.parse(PROJ_FLOW_VERSION)

PYTHON_EXECUTABLE = sys.executable


def python(
    *args: str,
    module: str | None = None,
    capture_output: bool = True,
) -> subprocess.CompletedProcess:
    if module is not None:
        return subprocess.run(
            [PYTHON_EXECUTABLE, "-m", module, *args],
            shell=False,
            capture_output=capture_output,
        )
    return subprocess.run(
        [PYTHON_EXECUTABLE, *args], shell=False, capture_output=capture_output
    )


def pip(*args: str, capture_output: bool = False):
    return python(*args, module="pip", capture_output=capture_output)


def venv(*args: str, capture_output: bool = False):
    return python(*args, module="venv", capture_output=capture_output)


def proj_flow_version(print_output=False):
    executable = shutil.which("proj-flow")
    if not executable:
        return None
    proc = subprocess.run(
        [executable, "--version"], encoding="utf-8", capture_output=True
    )
    result = Version.proc_parse(proc)
    if result is None and print_output:
        if proc.stdout:
            print(proc.stdout)
        if proc.stderr:
            print(proc.stderr, file=sys.stderr)
    return result


@contextmanager
def cd(path: Path):
    prev = Path().absolute()
    os.chdir(path)
    try:
        yield
    finally:
        os.chdir(prev)


def get_venv_path():
    bindir = Path(".venv", "bin")
    scripts = Path(".venv", "Scripts")

    if bindir.is_dir():
        return bindir

    if scripts.is_dir():
        return scripts

    return None


def activate_virtual_env():
    global PYTHON_EXECUTABLE

    with cd(PROJECT_ROOT):
        exec_ext = ".exe" if sys.platform == "win32" else ""
        python_exec = f"python{exec_ext}"
        bindir = get_venv_path()
        has_venv = bindir is not None and (bindir / python_exec).is_file()

        if not has_venv:
            venv(".venv")
            bindir = get_venv_path()

        if bindir is not None:
            os.environ["PATH"] = f"{bindir.absolute()}{os.pathsep}{os.environ['PATH']}"
            PYTHON_EXECUTABLE = shutil.which("python") or sys.executable


def bootstrap_cxx_flow():
    version = proj_flow_version()
    if proj_flow.compatible_with(version):
        return True

    if sys.prefix == sys.base_prefix:
        activate_virtual_env()

        version = proj_flow_version()
        if proj_flow.compatible_with(version):
            return True

    if pip("--version", capture_output=True).returncode != 0:
        print("Cannot call pip as a module. Exiting.\n", file=sys.stderr)
        sys.exit(1)

    if not version:
        print("Found no version of proj_flow package, installing from pypi.")
    elif version.major > proj_flow.major:
        print(
            f"Found proj_flow=={version}, need >={proj_flow} and <{proj_flow.major + 1}, installing from pypi."
        )
    else:
        print(f"Found proj_flow=={version}, need >={proj_flow}, installing from pypi.")

    if pip("install", f"proj-flow>={proj_flow},<{proj_flow.major + 1}").returncode != 0:
        print("Cannot install proj-flow with current pip. Exiting.\n", file=sys.stderr)
        sys.exit(1)

    return proj_flow.compatible_with(proj_flow_version(print_output=True))


def main():
    if not bootstrap_cxx_flow():
        print("Cannot find a working copy of proj-flow package", file=sys.stderr)
        return 1

    with cd(PROJECT_ROOT):
        executable = shutil.which("proj-flow")
        if executable is None:
            print("Cannot find a working copy of proj-flow executable", file=sys.stderr)
            return 1
        return subprocess.run([executable, *sys.argv[1:]]).returncode


if __name__ == "__main__":
    sys.exit(main())
